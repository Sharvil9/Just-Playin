<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compressing Loading Animation</title>
    <style>
        /* General body styling for centering and background */
        body {
            background-color: #1a1a1a;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Arial', sans-serif;
            position: relative;
        }
        
        /* Canvas styling to fill the viewport */
        #loadingCanvas {
            display: block;
            background-color: #1a1a1a;
        }

        /* Styling for the loading bar container */
        .loading-bar-container {
            position: absolute;
            bottom: 50px;
            width: 80%;
            max-width: 400px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        /* Styling for the animated loading bar itself */
        .loading-bar {
            height: 100%;
            width: 0%;
            border-radius: 5px;
            transition: width 0.1s linear; /* Smooth animation for the width change */
        }
        
        /* Styling for the percentage counter, now separate */
        #loadingCounter {
            position: absolute;
            bottom: 45px;
            left: calc(50% + 205px); /* Position to the right of the bar (max-width / 2 + some margin) */
            font-size: 1rem;
            width: 50px; /* Fixed width to prevent layout shifting */
            text-align: left;
        }
    </style>
</head>
<body>

    <!-- The canvas where the animation will be drawn -->
    <canvas id="loadingCanvas"></canvas>

    <!-- The loading bar and counter UI elements -->
    <div class="loading-bar-container">
        <div id="loadingBar" class="loading-bar"></div>
    </div>
    <div id="loadingCounter">0%</div>

    <script>
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('loadingCanvas');
        const ctx = canvas.getContext('2d');

        // Get the loading bar and counter elements
        const loadingBar = document.getElementById('loadingBar');
        const loadingCounter = document.getElementById('loadingCounter');

        // Animation properties
        const particleCount = 250; // Max number of particles
        let currentParticles = 0; // Number of particles currently on screen
        const particles = []; // Array to store particle objects
        const center = { x: 0, y: 0 }; // Center point of the canvas
        let progress = 0; // The loading progress, from 0 to 100
        const progressSpeed = 0.2; // How fast the loading bar fills up (slower now)
        let isFinalStage = false; // New flag for the final convergence stage
        let isStarburst = false; // New flag for the starburst stage

        // All available color palettes
        const colorPalettes = [
            // Palette 1
            [ '#42bcf5', '#3b82f6', '#a673f4', '#ff509e', '#db2777', '#f5d3d3', '#b2ff4a' ],
            // Palette 2 (Blue-black)
            [ '#242424', '#424242', '#3498db', '#6c757d', '#b1b1b1', '#d4d4d4', '#e6e6e6' ],
            // Palette 3 (Pink)
            [ '#8e004a', '#c2185b', '#e91e63', '#f48fb1', '#f8bbd0', '#fce4ec', '#ff69b4' ],
            // Palette 4 (Green)
            [ '#2e8b57', '#3cb371', '#66cdaa', '#90ee90', '#98fb98', '#adff2f', '#f0fff0' ]
        ];

        let currentPalette = []; // The active color palette
        let rafId; // Stores the requestAnimationFrame ID

        // Particle class definition
        class Particle {
            constructor(x, y, radius, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.originalRadius = radius;
                this.speed = 0.03; // Base speed for particles
                this.rotation = 0; // New property for rotation
                this.angle = Math.random() * Math.PI * 2; // For starburst effect
            }

            // Method to update the particle's position and size
            update() {
                // Starburst effect
                if (isStarburst) {
                    // Uneven, random burst speed
                    const burstSpeed = Math.random() * 5 + 1; 
                    this.x += Math.cos(this.angle) * burstSpeed; 
                    this.y += Math.sin(this.angle) * burstSpeed; 
                    this.radius *= 0.98; // Slower fade for a longer trail
                } else {
                    // Move the particle towards the center
                    this.x += (center.x - this.x) * this.speed;
                    this.y += (center.y - this.y) * this.speed;

                    // Shrink the particle as it moves towards the center
                    if (!isFinalStage) {
                        this.radius = this.originalRadius * (1 - this.distanceToCenter() / Math.min(canvas.width, canvas.height));
                    }
                    
                    // If the particle is too small, reset it (only in initial stage)
                    if (!isFinalStage && this.radius < 0.5) {
                        this.reset();
                    }
                }
            }

            // Method to draw the particle (now a question mark) with rotation on the canvas
            draw() {
                ctx.save(); // Save the current canvas state
                ctx.translate(this.x, this.y); // Move the origin to the particle's position
                ctx.rotate(this.rotation); // Rotate the canvas based on the particle's direction

                // Set the font style and color
                if (isStarburst) {
                    // Use a large size and pure white color for the burst effect
                    ctx.font = `${this.originalRadius * 5}px Arial`;
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.radius / this.originalRadius})`;
                } else {
                    ctx.font = `${this.radius * 2}px Arial`;
                    ctx.fillStyle = this.color;
                }

                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Draw the question mark character at the new origin (0, 0)
                ctx.fillText('?', 0, 0);
                
                ctx.restore(); // Restore the canvas to its previous state
            }

            // Method to calculate the distance to the center
            distanceToCenter() {
                const dx = center.x - this.x;
                const dy = center.y - this.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            // Method to reset the particle to a random edge position
            reset() {
                // Randomly choose an edge to spawn on
                const edge = Math.floor(Math.random() * 4);
                switch (edge) {
                    case 0: // Top edge - question mark faces down
                        this.x = Math.random() * canvas.width;
                        this.y = 0;
                        this.rotation = Math.PI; // 180 degrees
                        break;
                    case 1: // Right edge - question mark faces left
                        this.x = canvas.width;
                        this.y = Math.random() * canvas.height;
                        this.rotation = -Math.PI / 2; // -90 degrees
                        break;
                    case 2: // Bottom edge - question mark faces up
                        this.x = Math.random() * canvas.width;
                        this.y = canvas.height;
                        this.rotation = 0; // 0 degrees
                        break;
                    case 3: // Left edge - question mark faces right
                        this.x = 0;
                        this.y = Math.random() * canvas.height;
                        this.rotation = Math.PI / 2; // 90 degrees
                        break;
                }
                // Randomize initial radius and color for variety
                this.originalRadius = Math.random() * 20 + 10;
                this.radius = this.originalRadius;
                this.color = currentPalette[Math.floor(Math.random() * currentPalette.length)];
            }
        }

        // Initialize the animation by setting up canvas size and creating particles
        function init() {
            // Set canvas dimensions to match the window size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            center.x = canvas.width / 2;
            center.y = canvas.height / 2;

            // Select a random color palette for this cycle
            currentPalette = colorPalettes[Math.floor(Math.random() * colorPalettes.length)];

            // Update the loading bar's gradient to match the new palette
            const gradientColors = currentPalette.join(', ');
            loadingBar.style.backgroundImage = `linear-gradient(to right, ${gradientColors})`;

            // Clear the existing particles and reset all flags and progress
            particles.length = 0;
            currentParticles = 0;
            progress = 0;
            isFinalStage = false;
            isStarburst = false;
            loadingBar.style.width = '0%';
            loadingCounter.textContent = '0%';
            loadingCounter.style.color = currentPalette[Math.floor(currentPalette.length / 2)];
        }

        // The main animation loop
        function animate() {
            // Clear the canvas on each frame to redraw
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update the loading progress if not in the final stage
            if (!isFinalStage) {
                progress += progressSpeed;
            }

            if (progress >= 100) {
                progress = 100; // Cap at 100 to avoid flickering
                isFinalStage = true;
            }
            
            // Update the loading bar's width and the counter's text
            loadingBar.style.width = `${progress}%`;
            loadingCounter.textContent = `${Math.floor(progress)}%`;

            // Add new particles as the progress increases
            if (!isFinalStage && !isStarburst) {
                const targetParticles = Math.floor((progress / 100) * particleCount);
                while (currentParticles < targetParticles) {
                    const p = new Particle(0, 0, 0, 'white');
                    p.reset();
                    particles.push(p);
                    currentParticles++;
                }
            }

            // Update and draw each particle
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // Check for final convergence and trigger starburst
            if (isFinalStage && !isStarburst && particles.every(p => p.distanceToCenter() < 10)) {
                isStarburst = true;
                // Give each particle a new random angle for the starburst
                particles.forEach(p => {
                    p.x = center.x;
                    p.y = center.y;
                    p.radius = 20; // Start with a larger size for the effect
                    p.originalRadius = 20;
                    p.angle = Math.random() * Math.PI * 2;
                });
            }

            // Check if starburst is complete and restart
            if (isStarburst && particles.every(p => p.radius < 0.5)) {
                 setTimeout(() => {
                    init(); // Restart the animation cycle
                    // The requestAnimationFrame at the end of the loop will handle the next frame
                }, 500);
            }

            // Request the next animation frame
            rafId = requestAnimationFrame(animate);
        }

        // Event listener for window resize
        window.addEventListener('resize', init);

        // Start the animation when the window is loaded
        window.onload = function() {
            init();
            animate();
        };
    </script>
</body>
</html>
